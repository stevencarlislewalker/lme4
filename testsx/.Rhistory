count = c(1,2,10,3,4)
)
samp <- data.frame(samples=levels(x$samples), var1=c(1,2,1))
taxa <- data.frame(species=levels(x$species), var2=c("a","b","a"))
rownames(samp) <- samp$samples
rownames(taxa) <- taxa$species
dl2 <- dlcast(list(x,samp,taxa), c("samples","species"), fill=c(0,NA,NA))
expect_that(dl1, equals(dl2))
})
test_that("dims_to_vars works like [[<-.data.list",{
library(multitable)
data(fake.community)
dl1 <- dims_to_vars(fake.community, "years")
dl2 <- fake.community
dl2[["years", match.dimids = "years"]] <- dimnames(dl2)[[2]]
expect_that(dl1, equals(dl2))
dl1 <- dims_to_vars(fake.community)
dl2[["sites", match.dimids = "sites"]] <- dimnames(dl2)[[1]]
dl2[["species", match.dimids = "species"]] <- dimnames(dl2)[[3]]
dl2 <- dl2[c(1:6,8,7,9)] # must re-arrange the variable order
# to get exact equivalence
expect_that(dl1, equals(dl2))
})
test_that("variable addition works",{
library(multitable)
variable(matrix(runif(15), 5, 3), c("n","m"), "A") +
variable(letters[1:3], "m", "B") +
variable(runif(5), "n", "C") +
variable(array(runif(15*4), c(3,5,4)), c("m","n","p"), "D") +
variableGroup(data.frame(a = runif(5), b = runif(5)), "n") +
variableGroup(list(
c = matrix(runif(20), 4, 5),
d = matrix(runif(20), 4, 5)
), c("p","n"))
})
test_that("taxon names can be sorted without mismatch between taxon names and trait values",{
library(multitable)
n <- 10
m <- 5
set.seed(1)
species.names <- paste(
letters[ceiling(runif(m,0,26))],
letters[ceiling(runif(m,0,26))],
"_",
letters[ceiling(runif(m,0,26))],
letters[ceiling(runif(m,0,26))],
sep = ""
)
site.names <- paste(
letters[ceiling(runif(n,0,26))],
letters[ceiling(runif(n,0,26))],
letters[ceiling(runif(n,0,26))],
letters[ceiling(runif(n,0,26))],
sep = ""
)
abundance <- matrix(runif(n*m), n, m, dimnames = list(site.names, species.names))
env <- structure(runif(n), names = site.names)
trait <- factor(structure(letters[ceiling(runif(m,0,26))], names = species.names),
levels = letters[1:26])
dl1 <-
variable(abundance, c("sites","species"), "abundance") +
variable(env, "sites", "env") +
variable(trait, "species", "trait")
dl1 <- dl1[, order(trait)]
abundance <- abundance[, order(trait)]
trait <- trait[order(trait)]
dl2 <-
variable(abundance, c("sites","species"), "abundance") +
variable(env, "sites", "env") +
variable(trait, "species", "trait")
expect_that(dl1, equals(dl2))
})
#test_that("data lists with duplicated dimids should fail to be created",{
#	library(multitable)
#	em <- try(variable(matrix(1:4,2,2), rep("n",2), "square.matrix"), silent = TRUE)[1]
#	expect_that(em,equals("Error in as.data.list.default(x, dimids, match.dimids, check = check,  : \n  the dimensions of replication for\neach variable must be different\nfrom each other\n"))
#})
test_that("zombie factors in the dimid columns are handled appropriately with dlcast (test due to a reviewer of the JSS manuscript)",{
library(multitable)
x <- data.frame(
samples = paste("Sample", c(1,1,2,2,3,4), sep="."),
species = c(paste("Species", c(1,1,1,2,3), sep="."), "NONE"),
count = c(1,2,10,3,4,0))
samp <- data.frame(samples=levels(x$sample), var1=1:2)
taxa <- data.frame(species=levels(x$species), var2=c("b","a"))
rownames(samp) <- samp$samples
rownames(taxa) <- taxa$species
levels(x$species) <- c(levels(x$species), "sp.90","sp.91")
dl <- dlcast(list(x,samp,taxa), c("samples","species"), fill=c(0,NA,NA), placeholders = "NONE")
expect_that(levels(x$species)[-1], equals(dimnames(dl)[[2]]))
# make sure that it also works when dimid columns are not factors
x <- data.frame(
samples = c(1,1,2,2,3,4),
species = c(paste("Species", c(1,1,1,2,3), sep="."), "NONE"),
count = c(1,2,10,3,4,0))
samp <- data.frame(samples=1:4, var1=1:2)
taxa <- data.frame(species=levels(x$species), var2=c("b","a"))
rownames(samp) <- 1:4
rownames(taxa) <- taxa$species
levels(x$species) <- c(levels(x$species), "sp.90","sp.91")
dlcast(list(x,samp,taxa), c("samples","species"), fill=c(0,NA,NA), placeholders = "NONE")
expect_that(levels(x$species)[-1], equals(dimnames(dl)[[2]]))
})
test_that("variables created with variable are named correctly",{
library(multitable)
A <- 1:2
dl <- variable(A, "sites")
expect_that(names(dl), equals("A"))
})
test_that("automatic variable naming works with variable",{
library(multitable)
dl <- variable(matrix(runif(1:10), 5, 2), c("n","m"))
expect_that(names(dl), equals("matrix.runif(1:10).5.2"))
})
#test_that("mismatched dimensions don't work with data list arithmetic",{
#	library(multitable)
#	em <- try(variable(matrix(runif(10),5,2),c("n","m")) +
#		variable(runif(6), "n"), silent = TRUE)[1]
#	expect_that(em, equals("Error in Ops.data.list(variable(matrix(runif(10), 5, 2), c(\"n\", \"m\")),  : \n  some shared dimensions do not have the same length in both data lists\n"))
#})
test_that("data list arithmetic always results in a data list",{
dl <- variable(letters[1:5],"1") + variable(runif(5),"1")
expect_that(class(dl), equals("data.list"))
})
test_that("dlmelt is an inverse of dlcast (up to the order of replicates)",{
library(multitable)
data(fake.community)
fake.community.tortured <- dlcast(dlmelt(fake.community))
fake.community.sorted <- fake.community[
order(dimnames(fake.community)[[1]]),
order(dimnames(fake.community)[[2]]),
order(dimnames(fake.community)[[3]])
]
expect_that(fake.community.sorted, equals(fake.community.tortured))
})
test_that("dlapply works like apply on each variable",{
data(higgins)
sum.higgins <- as.list(dlapply(higgins, 1, quantile))[[1]]
expect_that(apply(higgins[[1]], 1, quantile), equals(sum.higgins))
})
test_that("ordered factors survive data list creation",{
library(multitable)
A <- matrix(1:12, 3, 4)
B <- ordered(c("a","b","b","a"))
dl <- data.list(A, B)
expect_that(is.ordered(dl$B), equals(is.ordered(B)))
})
test_that("the ordering of ordered factors survive data list creation",{
library(multitable)
A <- matrix(1:12, 3, 4)
B <- ordered(c("a","b","b","a"))
dl <- data.list(A, B)
expect_that(is.ordered(dl$B), equals(is.ordered(B)))
})
test_that("contrasts attached to factors survive data list creation",{
library(multitable)
A <- matrix(1:12, 3, 4)
B <- ordered(c("a","b","b","a"))
contrasts(B) <- contrasts(B)
dl <- data.list(A, B)
expect_that(is.null(attr(dl$B, "contrasts")), equals(FALSE))
})
test_that("'ordinatry' attributes survive data list creation",{
library(multitable)
A <- matrix(1:12, 3, 4)
B <- 1:3
attr(A, "foo") <- "bar"
dl <- data.list(A, B)
expect_that(attr(A, "foo"), equals(attr(dl$A, "foo")))
})
test_that("order of the MARGINs is respected by dlapply",{
library(multitable)
data(higgins)
dl <- higgins[1:4,,]
dl1 <- dlapply(dl, c(3, 1, 2), I)
dl2 <- aperm(dl, c(3, 1, 2))
expect_that(dl1, equals(dl2))
})
test_that("data.list doesn't fail for standard fourth-corner problems without dim names",{
library(multitable)
set.seed(1)
n <- 4
m <- 3
p <- 1
q <- 2
X <- matrix(rnorm(n*p), n, p)
Z <- matrix(rnorm(m*q), m, q)
C <- matrix(rnorm(p*q), p, q)
Y <- X %*% C %*% t(Z)
dl1 <- data.list(Y, as.data.frame(X), as.data.frame(Z))
dl2 <- data.list(as.data.frame(X), as.data.frame(Z), Y)
expect_that(dl1, equals(dl2[c(4, 1, 2, 3)]))
dl <- data.list(as.data.frame(X), Y, as.data.frame(Z))
dl <- data.list(as.data.frame(Z), Y, as.data.frame(X))
X <- rnorm(n)
dl1 <- data.list(Y, as.data.frame(X), as.data.frame(Z))
dl2 <- data.list(as.data.frame(X), as.data.frame(Z), Y)
expect_that(dl1, equals(dl2[c(4, 1, 2, 3)]))
dl <- data.list(as.data.frame(X), Y, as.data.frame(Z))
dl <- data.list(as.data.frame(Z), Y, as.data.frame(X))
Z <- rnorm(m)
dl1 <- data.list(Y, as.data.frame(X), as.data.frame(Z))
dl2 <- data.list(as.data.frame(X), as.data.frame(Z), Y)
expect_that(dl1, equals(dl2[c(3, 1, 2)]))
dl <- data.list(as.data.frame(X), Y, as.data.frame(Z))
dl <- data.list(as.data.frame(Z), Y, as.data.frame(X))
})
test_that("data.list doesn't fail for standard fourth-corner problems with dim names in Y",{
library(multitable)
set.seed(1)
n <- 4
m <- 3
p <- 1
q <- 2
X <- matrix(rnorm(n*p), n, p)
Z <- matrix(rnorm(m*q), m, q)
C <- matrix(rnorm(p*q), p, q)
Y <- X %*% C %*% t(Z)
dimnames(Y) <- list(letters[1:n], letters[1:m])
rownames(X) <- dimnames(Y)[[1]]
rownames(Z) <- dimnames(Y)[[2]]
dl <- data.list(as.data.frame(X), as.data.frame(Z), Y)
})
test_that("data.list doesn't fail for mefa-like data structure (i.e. 4th corner w more than one response matrix)",{
library(multitable)
set.seed(1)
n <- 4
m <- 3
p <- 1
q <- 2
X <- matrix(rnorm(n*p), n, p)
Z <- matrix(rnorm(m*q), m, q)
C <- matrix(rnorm(p*q), p, q)
Y1 <- X %*% C %*% t(Z) + matrix(rnorm(n*m), n, m)
Y2 <- X %*% C %*% t(Z) + matrix(rnorm(n*m), n, m)
dl1 <- data.list(Y1, Y2, as.data.frame(X), as.data.frame(Z))
dl2 <- data.list(as.data.frame(X), Y2, as.data.frame(Z), Y1)
dl3 <- data.list(list(Y1 = Y1, Y2 = Y2), as.data.frame(X), as.data.frame(Z))
expect_that(dl1, equals(dl2[c(5, 2, 1, 3, 4)]))
expect_that(dl1, equals(dl3))
})
#test_that("#2008 is fixed",{
#	library(multitable)
#	set.seed(1)
#	x <- runif(10)
#	y <- runif(11)
#	em <- try(data.list(x, y), silent = TRUE)[1]
#	THIS EXPECT_THAT IS NOT WRITTEN CORRECTLY BUT ITS NOT TO BE RUN ANYWAYS
#	expect_that(em, equals("Error in as.data.list.default(x, dimids, match.dimids, check = check,  :
#  at least one variable must be
#replicated along all dimensions"))
#})
test_that("dlapply works for simple fourth-corner data",{
library(multitable)
set.seed(1)
Y <- matrix(runif(10), 5, 2)
X <- runif(5)
Z <- runif(2)
dl <- data.list(Y, X, Z)
dl1 <- dlapply(dl, 1, sum)
dl2 <- dlapply(dl, 2, sum)
})
test_that("make.dimnames.consistent is in the right places",{
library(multitable)
set.seed(1)
Y <- matrix(rnorm(9), 3, 3)
x <- rnorm(3)
dl <- data.list(Y, x, match.dimids = list(c('D1','D2'),'D1'))
names(dl$x) <- letters[1:3]
dimnames(dl$Y) <- list(NULL, letters[1:3])
df <- as.data.frame(dl)
dl11 <- dl[1,1]
})
test_that("make.match.dimids works",{
library(multitable)
data(fake.community)
### FIRST HOW I DISCOVERED THE PROBLEM ###
l <- lapply(fake.community[-6], simple.scale)
as.data.list(l)
data.list(l[[1]], l[[2]], l[[3]], l[[4]], l[[5]])
### NOW A MINIMAL EXAMPLE ###
# reveals that the problem relates to properly named
# dimensions with the same number of replicates
set.seed(1)
Y <- matrix(rnorm(4), 2, 2)
x <- rnorm(2)
z <- rnorm(2)
rownames(Y) <- names(x) <- letters[1:2]
colnames(Y) <- names(z) <- letters[3:4]
data.list(Y, x, z)
data.list(Y, data.frame(x), data.frame(z))
data.list(data.frame(x), data.frame(z), Y)
})
test_that("dropdl works",{
library(multitable)
data(fake.community)
fc <- fake.community
dl1 <- fc[,1,]
dl1 <- dropdl(dl1)[1:3]
dl2 <- dl1[,1, drop = FALSE]
dropdl(dl2)
set.seed(1)
Y <- matrix(rnorm(6), 3, 2)
x <- rnorm(3)
z <- rnorm(2)
dl3 <- data.list(Y, x, z)
dropdl(dl3[,1])
})
test_that("bm attribute gets renamed properly when variables are renamed",{
library(multitable)
data(fake.community)
names(fake.community) <- LETTERS[seq_along(fake.community)]
bm1 <- attr(fake.community, 'bm')
bm2 <- 1
names(bm2) <- 'A'
expect_that(bm1, equals(bm2))
})
test_that("data list of a single vector becomes a data frame",{
library(multitable)
a <- runif(10)
a.dl <- as.data.list(a)
a.df <- as.data.frame(a)
expect_that(class(a.dl),is_equivalent_to(class(a.df)))
expect_that(class(a.dl),equals("data.frame"))
expect_that(unlist(a.dl),is_equivalent_to(unlist(a.df)))
})
library(multitable)
a <- runif(10)
a.dl <- as.data.list(a)
a.df <- as.data.frame(a)
a
debug(as.data.list)
as.data.list(a)
undebug(as.data.list)
as.data.list
as.data.list.default
multitable:::as.data.list.default
debug(multitable:::as.data.list.default)
as.data.list(a)
x
x
x
x
x
x
x
x
x
x
make.dimnames.consistent(x, bm)
length(repdim)
drop
as.data.frame(x)
Q
rm(list = ls())
library(multitable)
data(fake.community)
fake.community
dlmelt(fake.community)
fake.community
as.data.frame(fake.community)
library(lme4)
setwd('/users/stevenwalker/development/lme4/testsx/')
load('randcrabdata.RData')
parts <- glmer_form_parse(fr2, weights = initial.snail.density, family = 'binomial', data = randdata, verbose = 100, nAGQ = 1)
LL <- with(parts$reTrms, Lambdat %*% Zt %*% t(Zt) %*% t(Lambdat) + diag(1, 68, 68))
Lt <- chol(LL)
t(Lt)%*%Lt
LR <- with(parts$reTrms, Lambdat %*% Zt %*% parts$X)
Rzx <- solve(t(Lt), LR) # this might be Rzx???  or something like it.
Rzx
?Call
?.Call
Rzx
library(RcppEigen)
?RcppEigen
fastLm
fastLmPure
fastLm.formula
RcppEigen:::fastLm.formula
LR <- with(parts$reTrms, Lambdat %*% Zt %*% parts$X)
RcppEigen.package.skeleton( "foobar" )
pwd
pwd()
getwd()
RcppEigen.package.skeleton( "foobar" )
?Sparse
?sparse
Rzx
LL
?dgCMatrix
help("dgCMatrix")
debug(glmer)
glmer1 <- glmer(fr2, weights = initial.snail.density, family = 'binomial', data = randdata, verbose = 100, nAGQ = 1)
library(lme4)
setwd('/users/stevenwalker/development/lme4/testsx/')
load('randcrabdata.RData')
debug(glmer)
glmer1 <- glmer(fr2, weights = initial.snail.density, family = 'binomial', data = randdata, verbose = 100, nAGQ = 1)
Q
undebug(glmer)
parts <- glmer_form_parse(fr2, weights = initial.snail.density, family = 'binomial', data = randdata, verbose = 100, nAGQ = 1)
LL <- with(parts$reTrms, Lambdat %*% Zt %*% t(Zt) %*% t(Lambdat) + diag(1, 68, 68))
Lt <- chol(LL)
LR <- with(parts$reTrms, Lambdat %*% Zt %*% parts$X)
Rzx <- solve(t(Lt), LR) # this might be Rzx???  or something like it.
Rzx
parts$reTrms$Lambdat
parts$reTrms$Zt
parts$reTrms$X
dim(parts$reTrms$X)
length(parts$reTrms$X)
length(parts$X)
parts$X
unique(parts$X)
unique(as.vector(parts$X))
unique(as.vector(parts$X))
unique(as.vector(parts$reTerms$Zt))
unique(as.vector(parts$reTerms$Lambdat))
as.vector(parts$reTerms$Zt)
parts$reTerms$Zt
unique(as.vector(parts$reTrms$Zt))
unique(as.vector(parts$reTrms$Lambdat))
unique(as.vector(parts$X))
unique(as.vector(parts$reTrms$Zt))
unique(as.vector(parts$reTrms$Lambdat))
LR
unique(as.vector(LR))
sum(LR==0)
sum(LR==2)
sum(LR==1)
solve(LR)
?chol
image(Lambdat)
image(parts$reTrms$Lambdat)
image(parts$reTrms$Zt)
?Matrix
library(lme4)
setwd('/users/stevenwalker/development/lme4/testsx/')
load('randcrabdata.RData')
debug(glmer)
glmer1 <- glmer(fr2, weights = initial.snail.density, family = 'binomial', data = randdata, verbose = 100, nAGQ = 1)
LamZ <- with(parts$reTrms, Lambdat %*% Zt)
Q
undebug(glmer)
parts <- glmer_form_parse(fr2, weights = initial.snail.density, family = 'binomial', data = randdata, verbose = 100, nAGQ = 1)
LamZ <- with(parts$reTrms, Lambdat %*% Zt)
LamZ
library(lme4)
setwd('/users/stevenwalker/development/lme4/testsx/')
load('randcrabdata.RData')
debug(glmer)
glmer1 <- glmer(fr2, weights = initial.snail.density, family = 'binomial', data = randdata, verbose = 100, nAGQ = 1)
Ut <- with(parts$reTrms, Lambdat %*% Zt)
LL <- (Ut %*% t(Ut)) + diag(1, 68, 68)
Lt <- chol(LL)
Q
undebug(glmer)
Ut <- with(parts$reTrms, Lambdat %*% Zt)
LL <- (Ut %*% t(Ut)) + diag(1, 68, 68)
Lt <- chol(LL)
t(Lt)%*%Lt
LR <- Ut %*% parts$X)
LR <- Ut %*% parts$X
Rzx <- solve(t(Lt), LR) # this might be Rzx???  or something like it.
unique(as.vector(parts$X))
unique(as.vector(parts$reTrms$Zt))
unique(as.vector(parts$reTrms$Lambdat))
unique(as.vector(LR))
unique(as.vector(Rzx))
?update
parts$reTrms$L
parts$reTrms$lower
names(parts$reTrms)
mkMerMod
lme4:::mkMerMod
?glmer
gm1 <- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),
data = cbpp, family = binomial))
gm1 <- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),
data = cbpp, family = binomial)
gm1
gm1@re
class(gm1)
getSlots(class(gm1))
names(gm1@pp)
class(gm1@pp)
getSlots(class(gm1@pp))
mkMerMod
lme4:::mkMerMod
reTrms
parts$reTrms
names(parts$reTrms)
parts$reTrms$cnms
parts$reTrms$Lind
parts$reTrms$theta
getSlots(class(reTrms))
getSlots(class(gm1))
getSlots(class(gm1@resp))
gm1@resp
gm1@pp
names(gm1@pp)
class(gm1@pp)
getSlots(class(gm1@pp))
fields(class(gm1@pp))
class(gm1@pp)$fields()
gm1@pp$getRefClass()
gm1@pp$getRefClass()$fields()
gm1@pp$Lambdat
gm1@pp$getRefClass()$fields()
gm1@pp$Ptr
gm1@pp$RZX
